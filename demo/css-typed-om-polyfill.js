const _value$2=new WeakMap;class CSSKeywordValue{get value(){return _value$2.get(this)}set value(newValue){_value$2.set(this,String(newValue))}toString(){return`${this.value}`}constructor(...args){if(args.length<1)throw new TypeError(`Failed to construct 'CSSKeywordValue': 1 arguments required, but only ${args.length} present.`);_value$2.set(this,String(args[0]))}}Object.defineProperties(CSSKeywordValue.prototype,{value:{enumerable:!0}});const _value$1=new WeakMap;class CSSMathInvert{get operator(){return"invert"}get value(){return _value$1.get(this)}toString(){return`calc(1 / ${_value$1.get(this)})`}constructor(value){_value$1.set(this,value)}}const _values$3=new WeakMap;class CSSMathMax{get operator(){return"max"}get values(){return _values$3.get(this)}toString(){return`max(${_values$3.get(this).join(", ")})`}constructor(...values){_values$3.set(this,values)}}const _values$2=new WeakMap;class CSSMathMin{get operator(){return"min"}get values(){return _values$2.get(this)}toString(){return`min(${_values$2.get(this).join(", ")})`}constructor(...values){_values$2.set(this,values)}}const _values$1=new WeakMap;class CSSMathProduct{get operator(){return"product"}get values(){return _values$1.get(this)}toString(){return`calc(${_values$1.get(this).reduce(((contents,value)=>""+(value instanceof CSSMathInvert?`${contents?`${contents} / `:"1 / "}${value.value}`:`${contents?`${contents} * `:""}${value}`)),"")})`}constructor(...values){_values$1.set(this,values)}}const _values=new WeakMap;class CSSMathSum{get operator(){return"product"}get values(){return _values.get(this)}toString(){return`calc(${_values.get(this).reduce(((contents,value)=>`${contents?`${contents} + `:""}${value}`),"")})`}constructor(...values){_values.set(this,values)}}var units={number:"",percent:"%",em:"em",ex:"ex",ch:"ch",rem:"rem",vw:"vw",vh:"vh",vmin:"vmin",vmax:"vmax",cm:"cm",mm:"mm",in:"in",pt:"pt",pc:"pc",px:"px",Q:"Q",deg:"deg",grad:"grad",rad:"rad",turn:"turn",s:"s",ms:"ms",Hz:"Hz",kHz:"kHz",dpi:"dpi",dpcm:"dpcm",dppx:"dppx",fr:"fr"};class CSSNumericValue{add(...args){const Constructor=this.constructor,result=new Constructor(this.value,this.unit),values=[];for(let arg of args)if(arg instanceof Constructor)values.length||result.unit!==arg.unit?values.push(arg):result.value+=arg.value;else{if(!(arg instanceof CSSMathProduct||arg instanceof CSSMathMax||arg instanceof CSSMathMin||arg instanceof CSSMathInvert))return null;values.push(arg)}return values.length?new CSSMathSum(result,...values):result}div(...args){const Constructor=this.constructor,result=new Constructor(this.value,this.unit),values=[];for(let arg of args){if("number"==typeof arg&&(arg=new CSSUnitValue(arg,"number")),!(arg instanceof Constructor))return null;values.length||result.unit!==arg.unit&&"number"!==arg.unit?values.push(arg):result.value/=arg.value}return values.length?new CSSMathProduct(result,...values.map((value=>new CSSMathInvert(value)))):result}max(...args){const result=new CSSUnitValue(this.value,this.unit),values=[result];for(let arg of args){if(!(arg instanceof CSSUnitValue))return null;values.length>1||result.unit!==arg.unit?values.push(arg):result.value=Math.max(result.value,arg.value)}return values.length>1?new CSSMathMax(...values):result}min(...args){const result=new CSSUnitValue(this.value,this.unit),values=[result];for(let arg of args){if(!(arg instanceof CSSUnitValue))return null;values.length>1||result.unit!==arg.unit?values.push(arg):result.value=Math.min(result.value,arg.value)}return values.length>1?new CSSMathMin(...values):result}mul(...args){const Constructor=this.constructor,result=new Constructor(this.value,this.unit),values=[];for(let arg of args){if("number"==typeof arg&&(arg=new CSSUnitValue(arg,"number")),!(arg instanceof Constructor))return null;values.length||result.unit!==arg.unit&&"number"!==arg.unit?values.push(arg):result.value*=arg.value}return values.length?new CSSMathProduct(result,...values):result}sub(...args){const Constructor=this.constructor,result=new Constructor(this.value,this.unit),values=[];for(let arg of args){if(!(arg instanceof Constructor))return null;values.length||result.unit!==arg.unit?values.push(new Constructor(-1*arg.value,arg.unit)):result.value-=arg.value}return values.length?new CSSMathSum(result,...values):result}}const _value=new WeakMap,_unit=new WeakMap;class CSSUnitValue extends CSSNumericValue{get value(){return _value.get(this)}set value(newValue){_value.set(this,getFiniteNumber(newValue))}get unit(){return _unit.get(this)}toString(){return`${this.value}${units[this.unit]}`}constructor(...args){if(super(),args.length<2)throw new TypeError(`Failed to construct 'CSSUnitValue': 2 arguments required, but only ${args.length} present.`);_value.set(this,getFiniteNumber(args[0])),_unit.set(this,function(unit){if(!Object.keys(units).includes(unit))throw new TypeError(`Failed to construct 'CSSUnitValue': Invalid unit: ${unit}`);return unit}(args[1]))}}function getFiniteNumber(value){if(isNaN(value)||Math.abs(value)===1/0)throw new TypeError("Failed to set the 'value' property on 'CSSUnitValue': The provided double value is non-finite.");return Number(value)}Object.defineProperties(CSSUnitValue.prototype,{value:{enumerable:!0},unit:{enumerable:!0}});const unitKeys=Object.keys(units),unitValues=Object.values(units),unitParsingMatcher=new RegExp(`^([-+]?[0-9]*.?[0-9]+)(${unitValues.join("|")})?$`);class CSSStyleValue{constructor(){if("CSSStyleValue"===this.constructor.name)throw new TypeError("Illegal constructor")}static parse(property,cssText){return property.startsWith("--")?void 0:(property.toLowerCase(),(string=>{const unitParsingMatch=String(string).match(unitParsingMatcher);if(unitParsingMatch){const[,value,unit]=unitParsingMatch;return new CSSUnitValue(value,unitKeys[unitValues.indexOf(unit||"")])}return new CSSKeywordValue(string)})(cssText))}static parseAll(property,cssText){}}class CSSUnparsedValue extends CSSStyleValue{constructor(members=[]){if(super(!0),members.length<1)throw new TypeError(`Failed to construct 'CSSUnparsedValue': 1 argument required, but only ${members.length} present.`);this.members=members}*[Symbol.iterator](){yield*this.members}entries(){return this.members.entries()}forEach(callback,thisArg){this.members.forEach(callback,thisArg)}keys(){return this.members.keys()}values(){return this.members.values()}get(index){if(!(index<0||index>=this.length))return this.members[index]}set(index,val){if(index<0||index>=this.length)throw new RangeError(`Failed to set an indexed property on 'CSSUnparsedValue': The index provided (${index}) is outside the range [0, ${this.length-1}].`)}get length(){return this.members.length}}class StylePropertyMapReadOnly{constructor(){throw new TypeError("Illegal constructor")}get[Symbol.toStringTag](){return"StylePropertyMapReadOnly"}*[Symbol.iterator](){yield*this.entries()}get size(){return this.declarations.length}set size(_){return this.size}has(propertyName){let hasProp=!1;for(let i=0;i<this.declarations.length;i++)if(this.declarations.item(i)===propertyName){hasProp=!0;break}return hasProp}get(propertyName=null){if(!propertyName)throw new TypeError("Failed to execute 'get' on 'StylePropertyMap': 1 argument required, but only 0 present.");return this.declarations.getPropertyValue(propertyName)||null}getAll(propertyName){console.warn("StylePropertyMapReadOnly.getAll not implemented yet.")}*entries(){for(let i=0;i<this.declarations.length;i++){const propertyName=this.declarations.item(i),value=this.declarations.getPropertyValue(propertyName);yield[propertyName,CSSStyleValue.parse(propertyName,value)]}}forEach(callback,thisArg){for(let i=0;i<this.declarations.length;i++){const propertyName=this.declarations.item(i),value=this.declarations.getPropertyValue(propertyName);callback(CSSStyleValue.parse(propertyName,value),thisArg)}}*keys(){for(let i=0;i<this.declarations.length;i++)yield this.declarations.item(i)}*values(){for(let i=0;i<this.declarations.length;i++){const propertyName=this.declarations.item(i),value=this.declarations.getPropertyValue(propertyName);yield CSSStyleValue.parse(propertyName,value)}}}class StylePropertyMap extends StylePropertyMapReadOnly{get[Symbol.toStringTag](){return"StylePropertyMap"}append(){console.warn("StylePropertyMap.append not implemented yet.")}clear(){console.warn("StylePropertyMap.clear not implemented yet.")}delete(){console.warn("StylePropertyMap.delete not implemented yet.")}set(propertyName=null,propertyValue=null){if(!propertyName||!propertyValue)throw new TypeError("Failed to execute 'set' on 'StylePropertyMap': propertyName and propertyValue arguments are required.");this.declarations.setProperty(propertyName,String(propertyValue))}}function polyfill(window){window.CSS||(window.CSS=class{}),Object.keys(units).forEach((unit=>{unit in window.CSS||(window.CSS[unit]=value=>new CSSUnitValue(value,unit))})),"computedStyleMap"in window.Element.prototype||Object.defineProperty(window.Element.prototype,"computedStyleMap",{writable:!1,configurable:!1,value:function(){return function(declarations){const stylePropertyMapInstance=Object.create(StylePropertyMapReadOnly.prototype);return Object.defineProperty(stylePropertyMapInstance,"declarations",{value:declarations}),stylePropertyMapInstance}(window.getComputedStyle(this))}});const styleMapDescriptor={configurable:!1,enumerable:!0,get(){return function(declarations){const stylePropertyMap=Object.create(StylePropertyMap.prototype);return Object.defineProperty(stylePropertyMap,"declarations",{value:declarations}),stylePropertyMap}(this.style)}};"styleMap"in window.CSSStyleRule.prototype||Object.defineProperty(window.CSSStyleRule.prototype,"styleMap",styleMapDescriptor),"attributeStyleMap"in window.Element.prototype||Object.defineProperty(window.Element.prototype,"attributeStyleMap",styleMapDescriptor),window.CSSKeywordValue||(window.CSSKeywordValue=CSSKeywordValue),window.CSSMathInvert||(window.CSSMathInvert=CSSMathInvert),window.CSSMathMax||(window.CSSMathMax=CSSMathMax),window.CSSMathMin||(window.CSSMathMin=CSSMathMin),window.CSSMathProduct||(window.CSSMathProduct=CSSMathProduct),window.CSSMathSum||(window.CSSMathSum=CSSMathSum),window.CSSStyleValue||(window.CSSStyleValue=CSSStyleValue),window.CSSUnitValue||(window.CSSUnitValue=CSSUnitValue),window.CSSUnparsedValue||(window.CSSUnparsedValue=CSSUnparsedValue),window.StylePropertyMapReadOnly||(window.StylePropertyMapReadOnly=StylePropertyMapReadOnly),window.StylePropertyMap||(window.StylePropertyMap=StylePropertyMap)}export{CSSKeywordValue,CSSStyleValue,CSSUnitValue,StylePropertyMap,polyfill as default};
